// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tweets.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTweet = `-- name: CreateTweet :one
INSERT INTO tweets (
    user_id,
    tweet_id,
    content,
    file_url
) VALUES ($1, $2, $3, $4)
    RETURNING id, user_id, tweet_id, content, file_url, created_at
`

type CreateTweetParams struct {
	UserID  int64 `json:"user_id"`
	TweetID int64 `json:"tweet_id"`
	Content string      `json:"content"`
	FileUrl pgtype.Text `json:"file_url"`
}

func (q *Queries) CreateTweet(ctx context.Context, arg CreateTweetParams) (Tweets, error) {
	row := q.db.QueryRow(ctx, createTweet,
		arg.UserID,
		arg.TweetID,
		arg.Content,
		arg.FileUrl,
	)
	var i Tweets
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TweetID,
		&i.Content,
		&i.FileUrl,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTweet = `-- name: DeleteTweet :exec
DELETE FROM tweets
WHERE id = $1
`

func (q *Queries) DeleteTweet(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTweet, id)
	return err
}

const getTweetWithLikeStatus = `-- name: GetTweetWithLikeStatus :one
SELECT
    t.id, t.user_id, t.tweet_id, t.content, t.file_url, t.created_at,
    CASE
        WHEN l.user_id IS NOT NULL THEN TRUE
        ELSE FALSE
    END AS is_liked
FROM tweets t
LEFT JOIN likes l
    ON t.id=l.tweet_id AND l.user_id=$2
WHERE t.id=$1
LIMIT 1
`

type GetTweetWithLikeStatusParams struct {
	ID     int64       `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetTweetWithLikeStatusRow struct {
	ID        int64       `json:"id"`
	UserID    int64 `json:"user_id"`
	TweetID   int64 `json:"tweet_id"`
	Content   string      `json:"content"`
	FileUrl   string `json:"file_url"`
	CreatedAt time.Time   `json:"created_at"`
	IsLiked   bool        `json:"is_liked"`
}

func (q *Queries) GetTweetWithLikeStatus(ctx context.Context, arg GetTweetWithLikeStatusParams) (GetTweetWithLikeStatusRow, error) {
	row := q.db.QueryRow(ctx, getTweetWithLikeStatus, arg.ID, arg.UserID)
	var i GetTweetWithLikeStatusRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TweetID,
		&i.Content,
		&i.FileUrl,
		&i.CreatedAt,
		&i.IsLiked,
	)
	return i, err
}

const listTweets = `-- name: ListTweets :many
SELECT id, user_id, tweet_id, content, file_url, created_at FROM tweets
ORDER BY id
    LIMIT $1
OFFSET $2
`

type ListTweetsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTweets(ctx context.Context, arg ListTweetsParams) ([]Tweets, error) {
	rows, err := q.db.Query(ctx, listTweets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweets
	for rows.Next() {
		var i Tweets
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TweetID,
			&i.Content,
			&i.FileUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTweetsWithLikeStatus = `-- name: ListTweetsWithLikeStatus :many
SELECT
    t.id, t.user_id, t.tweet_id, t.content, t.file_url, t.created_at,
    EXISTS (
        SELECT 1 FROM likes l
        WHERE l.tweet_id = t.id
          AND l.user_id = $1
    ) AS is_liked
FROM tweets t
ORDER BY t.id
    LIMIT $2 OFFSET $3
`

type ListTweetsWithLikeStatusParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListTweetsWithLikeStatusRow struct {
	ID        int64       `json:"id"`
	UserID    int64 `json:"user_id"`
	TweetID   int64 `json:"tweet_id"`
	Content   string      `json:"content"`
	FileUrl   string `json:"file_url"`
	CreatedAt time.Time   `json:"created_at"`
	IsLiked   bool        `json:"is_liked"`
}

func (q *Queries) ListTweetsWithLikeStatus(ctx context.Context, arg ListTweetsWithLikeStatusParams) ([]ListTweetsWithLikeStatusRow, error) {
	rows, err := q.db.Query(ctx, listTweetsWithLikeStatus, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTweetsWithLikeStatusRow
	for rows.Next() {
		var i ListTweetsWithLikeStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TweetID,
			&i.Content,
			&i.FileUrl,
			&i.CreatedAt,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTweets = `-- name: ListUserTweets :many
SELECT id, user_id, tweet_id, content, file_url, created_at FROM tweets
WHERE user_id=$1
ORDER BY id
    LIMIT $2
OFFSET $3
`

type ListUserTweetsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListUserTweets(ctx context.Context, arg ListUserTweetsParams) ([]Tweets, error) {
	rows, err := q.db.Query(ctx, listUserTweets, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweets
	for rows.Next() {
		var i Tweets
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TweetID,
			&i.Content,
			&i.FileUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTweet = `-- name: UpdateTweet :one
UPDATE tweets
SET content=$2, file_url=$3
WHERE id = $1
    RETURNING id, user_id, tweet_id, content, file_url, created_at
`

type UpdateTweetParams struct {
	ID      int64       `json:"id"`
	Content string      `json:"content"`
	FileUrl string `json:"file_url"`
}

func (q *Queries) UpdateTweet(ctx context.Context, arg UpdateTweetParams) (Tweets, error) {
	row := q.db.QueryRow(ctx, updateTweet, arg.ID, arg.Content, arg.FileUrl)
	var i Tweets
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TweetID,
		&i.Content,
		&i.FileUrl,
		&i.CreatedAt,
	)
	return i, err
}
